# Oppitunti 12.3.2021 (luonnos)

T√§ll√§ oppitunnilla jatkamme JavaScript-kielen ja Node.js:n parissa. Tutustumme suosittuun [Express](https://expressjs.com/)-sovelluskehykseen, jonka avulla voimme toteuttaa JavaScript-pohjaisen verkkopalvelun. Lis√§ksi sivuamme JavaScriptin yksikk√∂testausta [Mocha](https://mochajs.org/)-ty√∂kalun avulla.


# Users ja Posts -teht√§v√§n malliratkaisu

[Edellisen oppitunnin](oppitunti1.md) teht√§v√§ss√§ teid√§n tuli yhdistell√§ Post-olioita User-olioihin hy√∂dynt√§en kuvitteellisen blogin JSON-tietorakenteita.

Teht√§v√§n ratkaisemiseksi oli useita erilaisia l√§hestymistapoja, ja t√§ll√§ tunnilla tutustumme funktionaaliseen l√§hestymistapaan, jossa k√§sittelemme aineiston map- ja filter-operaatioiden avulla.


# JS-koodin yksikk√∂testaaminen

Koodin testaamiseksi tarvitsemme testausty√∂kalun, joka voi olla esimerkiksi [Mocha](https://mochajs.org/). Mocha kannattaa asentaa NPM-ty√∂kalun avulla, ja jotta NPM k√§sittelee koodiamme projektina, tulee se alustaa seuraavalla komennolla:

```
$ npm init
```

T√§m√§n j√§lkeen voimme asentaa mocha-riippuvuuden NPM:n avulla:

```
$ npm install --save-dev mocha
```

Seuraavissa vaiheissa seuraamme Mochan dokumentaatiossa [https://mochajs.org/#getting-started](https://mochajs.org/#getting-started) olevia ty√∂vaiheita.


## Vertailu JavaScriptill√§

### Taulukoiden vertailu

Taulukoita vertailtaessa JavaScript tutkii, onko kyseess√§ sama taulukko. __Taulukoiden sis√§lt√∂j√§ ei vertailla.__

```js
> [1, 2, 3] === [1, 2, 3]
false
> [1, 2, 3] == [1, 2, 3]
false
```

### Olioiden vertailu

Kuten taulukoiden kanssa, my√∂s olioita vertailtaessa tarkastetaan ovatko oliot samat. __Olioiden sis√§lt√∂j√§ ei vertailla.__

```js
> { language: "JavaScript" } === { language: "JavaScript" }
false
> { language: "JavaScript" } == { language: "JavaScript" }
false
```

Eri kielet toimivat vertailujen osalta eri logiikalla. Esimerkiksi Python vertailee tietorakenteiden sis√§lt√∂√§:

```python
>>> [1, 2, 3] == [1, 2, 3] # Python
True
>>> { "language": "JavaScript" } == { "language": "JavaScript" } # Python
True
>>>
```

### deepStrictEqual

Koska olioiden vertaileminen vertailee vain, ovatko oliot samat, joudumme hy√∂dynt√§m√§√§n erillist√§ vertailulogiikkaa. Node-yksikk√∂testeiss√§ voimme hy√∂dynt√§√§ esimerkiksi `assert`-moduulin `deepStrictEqual`-metodia, joka vertailee rekursiivisesti sille annettuja arvoja:

```js
const assert = require('assert');

assert.deepStrictEqual([1, 2, 3], [1, 2, 3]):
assert.deepStrictEqual({ language: "JavaScript" }, { language: "JavaScript" });
```

https://nodejs.org/api/assert.html#assert_assert_deepstrictequal_actual_expected_message


### Totuusarvojen vertailu

JavaScriptiss√§ vertailuoperaatiot tehd√§√§n usein kolmella merkill√§ eli `===` tai `!==`. Kolmen merkin vertailuoperaatiot tarkastavat, ett√§ vertailtavien arvojen tyyppi on sama. Mik√§li tyyppitarkastus j√§tet√§√§n tekem√§tt√§, JavaScript vertailee tyhji√§ ja nollaan vertautuvia arvoja ep√§loogisesti.

Kahden yht√§suuruusmerkin vertailut tuottavat ep√§loogisia tuloksia esimerkiksi seuraavissa tapauksissa:

```js
> 1 == true
true
> "1" == true
true
> "0" == false  // nolla merkkijonona ja false
true
> [] == false   // tyj√§ taulukko ja false
true
> 0 == false    // nolla ja false
true
> 0 == "0"      // nolla merkkijonona ja nolla
true
> 0 == "+00000" // "pitk√§ nolla" etumerkill√§ merkkijonona
true
> 0 == []       // nolla ja tyhj√§ taulukko
true
> "0" == []     // molemmat ovat false, mutta silti kesken√§√§n erisuuruiset!! ü§Ø
false
```

Vertailu kolmella merkill√§ on helpommin arvattavissa, koska vertailussa sek√§ tyypin ett√§ arvon tulee olla sama:

```js
> 1 === true
false
> "1" === true
false
> "0" === false
false
> [] === false
false
> 0 === false
false
> 0 === "0"
false
> 0 === []
false
> "0" === []
false
```

Voit tutustua aiheeseen syv√§llisemmin YouTube-videolla [JavaScript == VS === (Web Dev Simplified)](https://www.youtube.com/watch?v=C5ZVC4HHgIg).


----


# ES6-syntaksien kertaus

Edellisell√§ oppitunnilla k√§sittelimme mm. seuraavassa koodiesimerkiss√§ esiintyvi√§ syntakseja:

```js
function helloAgent({ names }) {
    let { first, last } = names;
    console.log(`My name is ${last}, ${first} ${last}`);
}

module.exports = { helloAgent };
```

Miten t√§ss√§ moduuliss√§ m√§√§ritetty√§ `helloAgent`-funktiota voitaisiin kutsua toisesta Node.js-moduulista?



# Fetch-harjoitus

T√§h√§n asti olemme lukeneet k√§ytt√§jien ja postausten JSON-rakenteet paikallisesta tiedostosta `require`-funktiolla. T√§m√§ on tapahtunut synkronisesti, eli lukeminen on tehty loppuun ennen seuraavalle riville etenemist√§.

Tyypillisesti tiedostojen lukeminen, tietokantakyselyt ja http-pyynn√∂t tapahtuvat kuitenkin JavaScriptiss√§ asynkronisesti, eli vastausta ei j√§√§d√§ odottamaan, vaan ohjelman suoritus siirtyy suoraan eteenp√§in. Asynkronisten operaatioiden valmistumisen j√§lkeen niiden tuloksia pystyt√§√§n hy√∂dynt√§m√§√§n esimerkiksi Promise-olioiden ja then-metodin avulla.

Selaimissa HTTP-pyynt√∂j√§ tehd√§√§n usein JavaScriptin [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)-funktiolla. Nodessa ei ole valmista toteutusta fetch-funktiolle, mutta vastaava funktio saadaan asennettua `node-fetch`-pakettina:

> *"node-fetch: a light-weight module that brings window.fetch to Node.js"*
>
> https://www.npmjs.com/package/node-fetch

Node-fetch voidaan asentaa seuraavasti:

```
$ npm install node-fetch
```

HTTP-pyynt√∂ voidaan tehd√§ nyt sovelluksessa seuraavasti:

```js
const fetch = require('node-fetch');

let httpPromise = fetch('http://open-api.myhelsinki.fi/v1/events/');
```

Fetch-funktion sijasta voisimme k√§ytt√§√§ my√∂s muita HTTP-asiakaskirjastoja, kuten [axios](https://www.npmjs.com/package/axios). T√§ll√§ oppitunnilla k√§yt√§mme fetch-funktiota, koska se on hy√∂dynnett√§viss√§ suoraan eri selaimissa.


## Fetch, Promiset, async ja await

Asynkroniset kutsut, kuten `fetch`, palauttavat Promise-oliota:

> *"A Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.*"
>
> [MDN web docs. Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

Promise-olion tapahtumankuuntelija asetetaan kutsumalla Promisen `then`-metodia ja antamalla sille funktio, jota kutsutaan, kun promisen operaatio on valmistunut. Per√§kk√§isi√§ Promise-oliota voidaan my√∂s ketjuttaa, jolloin ensimm√§isen√§ Promisen `then`-metodille annettu funktio suoritetaan aina ennen seuraavia kutsuja, ja edelt√§v√§n funktion palauttama arvo v√§litet√§√§n aina seuraavalle funktiolle. T√§st√§ k√§ytet√§√§n my√∂s termi√§ "putkitus" eli piping.

Voit tutustua itsen√§isesti tarkemmin `fetch`-funktioon sek√§ sen palauttamien `Promise`-olioiden k√§ytt√§miseen seuraavien YouTube-videoiden avulla:

**[Google Chrome Developers: Using the Fetch API](https://youtu.be/Ri7WRoRcl_U)**

> *"The Fetch API is a modern replacement for XMLHttpRequest. It includes much of the code you used to write for yourself: handling redirection and error codes, and decoding the result. This video gives you an easy introduction."*

**[Google Chrome Developers: Intro to Promises (incl async/await)](https://youtu.be/7unX6hn5NA8)**

> *"Promises make asynchronous programming much easier than the traditional event-listener or callback approaches. This video explains promises, promise-chaining, and complex error-handling."*

## Tuntiesimerkki: fetch-kutsujen ja asynkronisuuden hy√∂dynt√§minen

Asynkroninen ohjelmointityyli tekee koodin kirjoittamisesta ajoittain hankalaa. Erityisesti tilanteissa, joissa tarvitsemme useita asynkronisia resursseja, joudumme kiinnitt√§m√§√§n suoritusj√§rjestykseen enemm√§n huomiota kuin olemme tottuneet tekem√§√§n Javan ja Pythonin kanssa.

Asynkronisuudesta on kuitenkin my√∂s hy√∂tyj√§: voimme k√§ynnist√§√§ useita asynkronisia operaatioita helposti ilman, ett√§ meid√§n t√§ytyy odottaa ensimm√§isten operaatioiden valmistumista.

T√§ll√§ tunnilla tutustumme siihen, miten Users ja Posts -esimerkki voidaan muuntaa tekem√§√§n k√§ytt√§jien ja postausten haku rinnakkain.


----


# Express.js

Nodelle on olemassa useita web-sovelluskehyksi√§, joista [express](https://www.npmjs.com/package/express) on hyvin suosittu:

> *"Fast, unopinionated, minimalist web framework for node."*
>
> https://www.npmjs.com/package/express

Asennetaan express seuraavasti:

```
$ npm install express
```

Liitet√§√§n seuraavaksi tapahtumien k√§sittely osaksi Expressin esimerkkisovellusta. Tarvoitteemme on, ett√§ palvelimemme vastaa pyynt√∂ihin JSON-rakenteella, joka on rajattu annettujen p√§iv√§m√§√§rien mukaan ja j√§rjestetty kronologiseen j√§rjestykseen. Lis√§ominaisuuksina voimme toteuttaa my√∂s "limit"-ominaisuuden tapahtumien m√§√§r√§n rajoittamiseksi.

```js
// https://www.npmjs.com/package/express
const express = require('express');
const app = express();
 
app.get('/', function (req, res) {
  res.send('Hello World');
})
 
app.listen(3000);
```

Harjoituksess√§ k√§yt√§mme query-parametreja p√§iv√§m√§√§rien rajaamiseksi:

* https://expressjs.com/en/4x/api.html#req.query

Palvelin vastaa pyynt√∂ihin JSON-muodossa:

* https://expressjs.com/en/4x/api.html#res.json

----


## Map: et√§isyyden lis√§√§minen kaikille tapahtumille

Meille erityisen hy√∂dyllinen `map`-operaation k√§ytt√∂tapaus voisi olla et√§isyyden lis√§√§minen tapahtuman tietoihin. Kaikilla tapahtumilla on koordinaatit, joten meid√§n tulee vain laskea et√§isyys kunkin tapahtuman koordinaattipisteen ja oman pisteemme v√§lill√§. Et√§isyyden laskeminen on sen verran monimutkainen operaatio, ett√§ emme halua toteuttaa sit√§ omaan koodiimme. Sen sijaan k√§yt√§mm evalmista `geolib`-kirjastoa:

> *"Library to provide basic geospatial operations like distance calculation, conversion of decimal coordinates to sexagesimal and vice versa, etc."*
>
> https://www.npmjs.com/package/geolib

Kirjasto asentuu `npm install`-komennolla seuraavasti:

```
npm install geolib
```

Nyt `geolib` voidaan ottaa k√§ytt√∂√∂n my√∂s omassa koodissa:

```js
const geolib = require('geolib');

const helsinkiCoordinates = { lat: 60.1733244, lon: 24.9410248 };

let eventsWithDistance = events.map(event => {
    let eventCoordinates = { lat, lon } = event.location;
    return {
        ...event, // "object spread"
        distance: geolib.getDistance(helsinkiCoordinates, eventCoordinates) // lis√§t√§√§n uusi attribuutti!
    }
});
```

Huomaa, ett√§ yll√§ oleva koodi ei muuta alkuper√§ist√§ `events`-taulukkoa eik√§ sill√§ olevia olioita, vaan se luo uuden taulukon, joka t√§ytet√§√§n kopioilla tapahtumista.


### Currying

Yll√§ olevassa koodiesimerkiss√§ `map`-operaatiolle annettu funktio on sidottu `helsinkiCoordinates`-muuttujaan. Haluaisimme kuitenkin ohjelmassamme todenn√§k√∂isesti laskea et√§isyyksi√§ monipuolisesti, joten eri et√§isyysfunktiot olisi tarpeen sitoa eri muuttujien arvoihin:

```js
const helsinkiCoordinates = { lat: 60.1733244, lon: 24.9410248 };
const espooCoordinates = { lat: 60.205491, lon: 24.655900 };
const rovaniemiCoordinates = { lat: 66.503059, lon: 25.726967 };
```

Voimme ratkaista ongelman soveltaen currying-tekniikkaa! Ensin lukitsemme koordinaattipisteen ja sen j√§lkeen kutsumme sisemp√§√§ funktiota tapahtumaolioiden kanssa!

```js
function getDistanceTo(point) {
    return function (event) {
        return geolib.getDistance(point, event.location);
    }
}

// sama kuin:
let getDistanceTo = (point) => (event) => geolib.getDistance(point, event.location);
```

Nyt et√§isyysfunktioita voidaan luoda kutsumalla `getDistanceTo`-funktioita eri koordinaattipisteill√§. Funktio palauttaa aina uuden funktion, jonka sulkeumassa annettu koordinaattipiste on tallessa:

```js
// et√§isyysfunktiot Helsinkiin ja Tukholmaan
let distanceFuncHelsinki = getDistanceTo(helsinkiCoordinates);
let distanceFuncStockholm = getDistanceTo(stockholmCoordinates);

// et√§isyysfunktioiden hy√∂dynt√§minen tapahtuman kanssa:
let distaceHki = distanceFuncHelsinki(events[0]);
let distaceSto = distanceFuncStockholm(events[0]);

// et√§isyyden lis√§√§minen kaikkiin tapahtumiin!
let eventsWithCoordinates = events.map(event => ({ ...event, distance: distanceFuncHelsinki(event) }) );
events.forEach(event => event.distance = distanceFuncHelsinki(event));
```

**Pohdittavaa**

JavaScriptin taulukoilla on my√∂s `forEach`-funktio, jonka avulla tietty funktio voidaan suorittaa taulukon jokaiselle arvolle. Miten `forEach`-funktion k√§ytt√§minen poikkeaa `map`-funktion k√§ytt√§misest√§ seuraavassa esimerkiss√§? Mitk√§ ovat niiden vahvuudet ja heikkoudet?

```js
// map:
let eventsWithCoordinates = events.map(event => ({ ...event, distance: distanceFuncHelsinki(event) }) );

// forEach:
events.forEach(event => event.distance = distanceFuncHelsinki(event));
```

<!--
```js
function addDistanceTo(coordinates) {
    return function(event) {
        return {
            ...event,
            distance: geolib.getDistance(coordinates, event.location)
        } 
    }
}
```

Nyt tapahtumille saadaan lis√§tty√§ et√§isyys Helsingin koordinaateista suoraviivaisesti:

```js
let addDistanceToHelsinki = addDistanceTo(helsinkiCoordinates);
let eventsWithDistanceFromHelsinki = events.map(addDistanceToHelsinki);
```
-->

### Tapahtumien j√§rjest√§minen et√§isyyden mukaan

Kun tapahtumille on lis√§tty uusi attribuutti `distance`, voidaan t√§t√§ k√§ytt√§√§ hyv√§ksi my√∂s tapahtumien j√§rjest√§misess√§ et√§isyyden mukaan. Seuraavan koodiesimerkin nuolifunktio vertailee kahta tapahtumaa niiden `distance`-attribuutin mukaan:

```js
// Jos et√§isyys 1 on pienempi kuin et√§isyys 2, on tuloksena negatiivinen luku:
eventsWithDistances.sort((event1, event2) => event1.distance - event2.distance);
```

Katso lis√§tietoa j√§rjest√§misest√§ ylemp√§√§ kodasta "J√§rjest√§minen alkamisajan mukaan".

----

----






# Teht√§v√§: postinumerot-backend (luonnos)

Toteutetaan backend, jonka kautta voidaan pyyt√§√§ postitoimipaikan nimi postinumerolle, tai postinumerot toimipaikan nimell√§.

## Arvosanatavoite 3

## Arvosanatavoite 5

<!--
  let title; // Tarkastetaan onko suomenkielist√§ name atribuuttia saatavilla
  if (props.item.name.fi !== null) {
    // jos ei ole k√§ytet√§√§n englanninkieleist√§
    title = props.item.name.fi;
  } else if (props.item.name.en !== null) {
    title = props.item.name.en;
  }
-->
